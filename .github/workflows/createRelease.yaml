name: Windows & Linux CI Release

permissions:
  contents: write

on:
  push:
    tags: ["v*.*.*"]
  workflow_dispatch:

env:
  DIST_DIR: "dist"
  VCPKG_LIBRARY_LINKAGE: dynamic

jobs:
  build-windows:
    runs-on: windows-latest
    strategy:
      fail-fast: false
      matrix:
        python-version: ["3.13", "3.14"]
    env:
      SKBUILD_CONFIG: Release
      VCPKG_TARGET_TRIPLET: x64-windows-release
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
          cache: "pip"

      - name: Setup MSVC environment
        uses: ilammy/msvc-dev-cmd@v1

      - name: Upgrade pip & install deps
        run: |
          python -m pip install --upgrade pip setuptools wheel
          python -m pip install scikit-build-core pybind11 numpy ninja
          python -m pip install torch==2.9.1 torchvision==0.24.1 --index-url https://download.pytorch.org/whl/cu130

      - name: Cache vcpkg
        uses: actions/cache@v4
        with:
          path: |
            ${{ runner.temp }}/vcpkg
            ${{ runner.temp }}/vcpkg/installed
            ${{ runner.temp }}/vcpkg/archives
          key: vcpkg-${{ runner.os }}-${{ env.VCPKG_TARGET_TRIPLET }}-dav1d-v2-${{ hashFiles('pyproject.toml') }}
          restore-keys: |
            vcpkg-${{ runner.os }}-${{ env.VCPKG_TARGET_TRIPLET }}-dav1d-v2-

      - name: Bootstrap vcpkg
        shell: powershell
        run: |
          if (-not (Test-Path "${{ runner.temp }}/vcpkg")) {
            git clone https://github.com/microsoft/vcpkg.git "${{ runner.temp }}/vcpkg"
          }
          & "${{ runner.temp }}/vcpkg/bootstrap-vcpkg.bat" -disableMetrics

      - name: Update vcpkg ports
        shell: cmd
        run: |
          cd "${{ runner.temp }}\vcpkg"
          git fetch origin master
          git reset --hard origin/master
          git clean -fd

      - name: Set VCPKG env vars
        shell: bash
        run: |
          echo "VCPKG_ROOT=${RUNNER_TEMP}/vcpkg"                          >> $GITHUB_ENV
          echo "VCPKG_TOOLCHAIN_FILE=${RUNNER_TEMP}/vcpkg/scripts/buildsystems/vcpkg.cmake" >> $GITHUB_ENV
          echo "VCPKG_TARGET_TRIPLET=x64-windows-release"                        >> $GITHUB_ENV
          echo "CMAKE_PREFIX_PATH=${RUNNER_TEMP}/vcpkg/installed/x64-windows-release"                       >> $GITHUB_ENV

      - name: Install C++ deps via vcpkg
        shell: cmd
        run: |
          "${{ runner.temp }}\vcpkg\vcpkg" install spdlog fmt libyuv --triplet x64-windows-release --recurse

      - name: Download FFmpeg for build (headers/libs only)
        shell: powershell
        run: |
          # FFmpeg is needed for headers/import libs at build time
          # The DLLs are NOT bundled - users must have FFmpeg in their PATH
          $FFmpegUrl = "https://www.gyan.dev/ffmpeg/builds/ffmpeg-release-full-shared.7z"
          $OutputDir = "${{ github.workspace }}/external/ffmpeg"
          $TempDir = "${{ runner.temp }}/ffmpeg_download"

          New-Item -ItemType Directory -Path $TempDir -Force | Out-Null
          New-Item -ItemType Directory -Path $OutputDir -Force | Out-Null

          Write-Host "Downloading FFmpeg (for build-time headers/libs only)..."
          Start-BitsTransfer -Source $FFmpegUrl -Destination "$TempDir/ffmpeg.7z"

          Write-Host "Extracting FFmpeg..."
          7z x "$TempDir/ffmpeg.7z" -o"$TempDir/extracted" -y

          $FFmpegDir = Get-ChildItem -Path "$TempDir/extracted" -Directory | Select-Object -First 1
          # Copy all directories including bin (needed for running tests, but NOT bundled by CMake)
          Copy-Item -Path "$($FFmpegDir.FullName)/bin" -Destination $OutputDir -Recurse -Force
          Copy-Item -Path "$($FFmpegDir.FullName)/lib" -Destination $OutputDir -Recurse -Force
          Copy-Item -Path "$($FFmpegDir.FullName)/include" -Destination $OutputDir -Recurse -Force

          Write-Host "=== FFmpeg installed (headers/libs for build, bin for testing) ==="

      - name: Setup CUDA toolkit
        uses: Jimver/cuda-toolkit@v0.2.30
        id: cuda-toolkit
        with:
          cuda: "13.0.0"
          method: "local"
          use-github-cache: true
          use-local-cache: true

      - name: Verify and Fix CUDA installation
        shell: bash
        run: |
          echo "CUDA_PATH: ${{ steps.cuda-toolkit.outputs.CUDA_PATH }}"
          ls -la "${{ steps.cuda-toolkit.outputs.CUDA_PATH }}/bin/" | head -20
          "${{ steps.cuda-toolkit.outputs.CUDA_PATH }}/bin/nvcc.exe" --version

          CUDA_INC="${{ steps.cuda-toolkit.outputs.CUDA_PATH }}/include"
          echo "Checking for host_config.h in $CUDA_INC..."

          # CUDA 13.x moved host_config.h - fix by ensuring it exists in include/crt/
          if [ -f "$CUDA_INC/crt/host_config.h" ]; then
            echo "SUCCESS: host_config.h found at include/crt/"
          elif [ -f "$CUDA_INC/host_config.h" ]; then
            echo "FOUND: host_config.h at include/ (CUDA 13.x location)"
            echo "FIXING: Copying to include/crt/host_config.h for compatibility..."
            mkdir -p "$CUDA_INC/crt"
            cp "$CUDA_INC/host_config.h" "$CUDA_INC/crt/host_config.h"
            echo "FIX APPLIED."
          else
            echo "FATAL: host_config.h NOT found!"
            echo "CUDA installation is incomplete. Cannot build CUDA wheel."
            find "${{ steps.cuda-toolkit.outputs.CUDA_PATH }}" -name "host_config.h" || true
            exit 1
          fi

      - name: Build Windows wheel
        shell: bash
        env:
          CMAKE_GENERATOR: Ninja
          SKBUILD_CONFIG: Release
          NELUX_ENABLE_CUDA: "ON"
        run: |
          # Convert backslashes to forward slashes to avoid CMake escaping issues on Windows
          TEMP_FWD=$(echo "$RUNNER_TEMP" | tr '\\' '/')

          # Sanitize CUDA_PATH path as well
          CUDA_PATH_FWD=$(echo "$CUDA_PATH" | tr '\\' '/')
          export CUDA_PATH="$CUDA_PATH_FWD"

          export VCPKG_ROOT="${TEMP_FWD}/vcpkg"
          export VCPKG_TOOLCHAIN_FILE="${VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake"
          export VCPKG_TARGET_TRIPLET=x64-windows-release
          export CMAKE_PREFIX_PATH="${VCPKG_ROOT}/installed/x64-windows-release"

          # Construct CMAKE_ARGS with sanitized paths AND FORCE NELUX_ENABLE_CUDA=ON
          export CMAKE_ARGS="-DCMAKE_TOOLCHAIN_FILE=${VCPKG_TOOLCHAIN_FILE} -DVCPKG_TARGET_TRIPLET=${VCPKG_TARGET_TRIPLET} -DCMAKE_PREFIX_PATH=${CMAKE_PREFIX_PATH} -DNELUX_ENABLE_CUDA=ON"

          echo "CMAKE_ARGS: $CMAKE_ARGS"
          # Use --no-build-isolation so we usage the pre-installed CUDA-enabled Torch
          python -m pip wheel . --no-deps --no-build-isolation -w dist -v

      - name: Debug - List nelux folder and wheel contents
        shell: powershell
        run: |
          Write-Host "=== Contents of nelux/ folder (post-build) ==="
          Get-ChildItem -Path nelux -Recurse | ForEach-Object { 
            Write-Host "$($_.Length) bytes - $($_.FullName)" 
          }
          Write-Host "=== Contents of dist/ folder ==="
          Get-ChildItem -Path dist | ForEach-Object { 
            Write-Host "$($_.Length) bytes - $($_.Name)" 
          }

      - name: Repair wheel with delvewheel (bundle DLLs)
        shell: powershell
        run: |
          Write-Host "=== Installing delvewheel ==="
          pip install delvewheel

          Write-Host "=== Setting up DLL search paths ==="
          $VcpkgBin = Join-Path $env:RUNNER_TEMP "vcpkg\installed\x64-windows-release\bin"
          $CudaBin = Join-Path $env:CUDA_PATH "bin"

          # Locating Torch DLLs (needed so delvewheel finds them, but we EXCLUDE them from bundling)
          $TorchSite = python -c "import torch, os; print(os.path.dirname(torch.__file__))"
          $TorchLib = Join-Path $TorchSite "lib"

          # FFmpeg DLLs (for build/test, but NOT bundled)
          $FFmpegBin = "${{ github.workspace }}/external/ffmpeg/bin"

          # Dynamically get list of ALL FFmpeg DLLs to exclude them
          $FFmpegDlls = Get-ChildItem -Path $FFmpegBin -Filter "*.dll" | Select-Object -ExpandProperty Name
          $FFmpegExclude = $FFmpegDlls -join ";"

          Write-Host "VCPKG bin: $VcpkgBin"
          Write-Host "CUDA bin: $CudaBin"
          Write-Host "Torch lib: $TorchLib"
          Write-Host "FFmpeg bin: $FFmpegBin"
          Write-Host "Excluding FFmpeg DLLs: $FFmpegExclude"

          # Find the wheel file
          $WheelFile = Get-ChildItem dist/*.whl | Select-Object -First 1
          Write-Host "Repairing wheel: $($WheelFile.FullName)"

          New-Item -ItemType Directory -Path dist_repaired -Force | Out-Null

          # Run delvewheel repair
          delvewheel repair $WheelFile.FullName `
            --add-path "$VcpkgBin" `
            --add-path "$CudaBin" `
            --add-path "$TorchLib" `
            --add-path "$FFmpegBin" `
            --exclude "torch_cpu.dll;c10.dll;torch_python.dll;torch.dll;torch_cuda.dll;$FFmpegExclude" `
            --wheel-dir dist_repaired `
            -v

          # Replace original wheel with repaired one
          Remove-Item dist/*.whl -Force
          Move-Item dist_repaired/*.whl dist/
          Remove-Item dist_repaired -Recurse -Force
          Write-Host "=== Wheel repair complete ==="

      - name: List wheel contents
        run: |
          echo "=== Wheel contents (CUDA DLLs bundled via delvewheel, FFmpeg NOT bundled) ==="
          unzip -l dist/*.whl | grep nelux/

      - name: Test wheel import and API
        shell: powershell
        run: |
          Write-Host "=== Installing wheel and testing import ==="
          pip install (Get-ChildItem dist/*.whl) --force-reinstall

          # Add FFmpeg bin to PATH for the test
          $FFmpegBin = Join-Path $pwd "external\ffmpeg\bin"
          Write-Host "Adding to PATH: $FFmpegBin"
          $env:PATH = "$FFmpegBin;$env:PATH"
          $env:FFMPEG_BIN = $FFmpegBin

          # Check torch and basic import with explicit DLL path adding for FFmpeg
          python -c "import os, sys, torch; os.add_dll_directory(os.environ['FFMPEG_BIN']) if os.path.exists(os.environ.get('FFMPEG_BIN', '')) else None; import nelux; print(f'torch {torch.__version__}, nelux {nelux.__version__}')"

          # Verify 0.8.3 API features are present
          Write-Host "--- Verifying 0.8.3 API Features ---"
          $ApiCode = @'
          import os
          import sys

          # Ensure FFmpeg DLLs can be loaded
          ffmpeg_bin = os.environ.get('FFMPEG_BIN', '')
          if os.path.exists(ffmpeg_bin):
              print(f"Adding DLL directory: {ffmpeg_bin}")
              os.add_dll_directory(ffmpeg_bin)

          import nelux
          
          # Set up DLL paths for the C extension before importing it directly
          # The C extension needs FFmpeg and other bundled DLLs
          nelux_dir = os.path.dirname(nelux.__file__)
          if hasattr(os, 'add_dll_directory'):
              # Add nelux package directory for bundled DLLs (libyuv, etc.)
              os.add_dll_directory(nelux_dir)
              # Also check for nelux.libs subdirectory (where delvewheel puts DLLs)
              libs_dir = os.path.join(nelux_dir, 'nelux.libs')
              if os.path.exists(libs_dir):
                  os.add_dll_directory(libs_dir)
          
          # Import the C extension module directly to check API without instantiating
          from nelux import _nelux
          
          # Get the actual VideoReader class from C++ extension
          vr_class = _nelux.VideoReader
          
          # Prefetch API
          assert hasattr(vr_class, 'start_prefetch'), 'MISSING: start_prefetch'
          assert hasattr(vr_class, 'stop_prefetch'), 'MISSING: stop_prefetch'
          # These are properties in pybind11
          assert hasattr(vr_class, 'prefetch_buffered'), 'MISSING: prefetch_buffered'
          assert hasattr(vr_class, 'is_prefetching'), 'MISSING: is_prefetching'
          assert hasattr(vr_class, 'prefetch_size'), 'MISSING: prefetch_size'

          # Reconfigure API
          assert hasattr(vr_class, 'reconfigure'), 'MISSING: reconfigure'
          assert hasattr(vr_class, 'file_path'), 'MISSING: file_path'

          print('All 0.8.3 API features verified!')
          '@
          $ApiCode | Set-Content -Path "verify_api.py" -Encoding UTF8
          python verify_api.py

      - name: Upload Windows wheel
        uses: actions/upload-artifact@v4
        with:
          name: windows-wheel-Release-py${{ matrix.python-version }}
          path: "dist/*.whl"

  release:
    needs: [build-windows]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Download Windows wheels
        uses: actions/download-artifact@v4
        with:
          pattern: windows-wheel-Release-py*
          path: dist
          merge-multiple: true
      - name: List all files for debug
        run: ls -lR dist
      - name: Install tomllib (if needed)
        run: python3 -m pip install toml pybind11
      - name: Extract version from pyproject.toml
        id: get_version
        shell: bash
        run: |
          VERSION=$(python3 -c "import tomllib; print(tomllib.load(open('pyproject.toml', 'rb'))['project']['version'])")
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "version=$VERSION" >> $GITHUB_OUTPUT
      - name: Extract changelog for this version
        id: get_changelog
        shell: bash
        run: |
          # Extract content between the first version header and the next version header (or end of relevant content)
          # The changelog format uses: ### **Version X.Y.Z (YYYY-MM-DD)**
          CHANGELOG_CONTENT=$(awk '
            /^### \*\*Version / {
              if (found) exit;  # Stop at the next version header
              found=1;
              next;  # Skip the version header line itself
            }
            found && /^---$/ { exit; }  # Stop at horizontal rule separator
            found { print; }
          ' docs/CHANGELOG.md)

          # Write to a file to preserve multiline content
          echo "$CHANGELOG_CONTENT" > changelog_excerpt.md

          # Also set as output (escaped for GitHub Actions)
          {
            echo 'changelog<<EOF'
            cat changelog_excerpt.md
            echo 'EOF'
          } >> $GITHUB_OUTPUT
      - name: Create tag for this version
        run: |
          git config --global user.email "actions@github.com"
          git config --global user.name "GitHub Actions"
          git tag v${{ env.VERSION }}
          git push origin v${{ env.VERSION }}
      - name: Flatten wheel artifacts to top-level dist/
        run: |
          find dist -name '*.whl' -exec mv {} dist/ \;
      - name: Create GitHub Release
        uses: ncipollo/release-action@v1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          tag: v${{ env.VERSION }}
          name: Release v${{ env.VERSION }}
          bodyFile: changelog_excerpt.md
          artifacts: "dist/*.whl"

  pypi-publish:
    needs: release
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master'
    environment:
      name: pypi
      url: https://pypi.org/p/nelux
    permissions:
      id-token: write
    steps:
      - name: Download Windows wheels
        uses: actions/download-artifact@v4
        with:
          pattern: windows-wheel-Release-py*
          path: dist
          merge-multiple: true

      - name: Flatten wheels into top-level dist/
        run: |
          mkdir -p upload
          find dist -type f -name '*.whl' -exec mv -t upload {} +
          find dist -type f -name '*.tar.gz' -exec mv -t upload {} + || true
          rm -rf dist
          mv upload dist
          ls -l dist

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_TOKEN }}
          skip-existing: true
